## 자료구조 Data Structure
1. Array와 ArrayList의 차이점에 대해 설명해주세요.  
```
Array는 크기가 고정적이고, ArrayList는 크기가 가변적입니다.
Array는 초기화 시 메모리에 할당되어 ArrayList보다 속도가 빠르고, ArrayList는 데이터 추가 및 삭제 시 메모리를 재할당하기 때문에 속도가 Array보다 느립니다. Array는 다차원으로 구성이 가능하고 ArrayList는 불가능하다는 차이점도 있습니다.
```

2. Array와 LinkedList의 차이점과 각각의 장/단점에 대해 설명해주세요.  
```
Array는 초기화 시 정해진 크기로 만들어지는 배열이고, LinkedList는 노드들 간의 연결 정보를 통해 리스트를 구현하는 동적인 크기의 리스트입니다.
Array는 크기를 정해 효율적인 메모리 사용이 가능하며, 인덱스로 접근 시 O(1)의 시간 복잡도를 갖지만 요소의 삭제가 불가능하다는 특징이 있습니다.
LinkedList는 동적인 할당으로 유연성이 높고 리스트 중간 요소의 삭제가 가능하지만 중간 요소 접근 시 링크를 기준으로 접근하기 때문에 O(n)이라는 시간 복잡도를 갖습니다.
```

3. Dynamic Array를 설명하고 Linked List와 비교해주세요.
```
Dynamic Array는 배열을 선언한 후 resize를 통해 유동적으로 size를 조절해 데이터를 저장하는 자료구조입니다. 배열의 크기가 고정적이라는 한계를 보완할 수 있는 자료구조입니다.
Linked List와 비교하여 Dynamic Array의 장점은 데이터의 접근과 할당이 O(1)로 굉장히 빠르고(할당된 크기 내에서), 맨 뒤에 데이터를 추가하거나 삭제하는 것이 상대적으로 빠릅니다.
상대적 단점으로는 데이터를 맨 끝이 아닌 곳(또는 할당된 크기보다 커지게 될 경우에 새로운 배열에 옮겨주는 시간이 추가되기 때문에)에 삽입/삭제할 경우 O(N)으로 느리고, resize를 할 때 현저이 낮은 성능을 보입니다. 또한 필요 이상의 메모리 공간을 할당받아 낭비되는 공간이 발생합니다.
```

4. List와 Map, Set의 차이점에 대해 설명해주세요.  
```
List는 순서와 중복이 있는 자료구조로 크기가 가변적이고 인덱스로 원소에 접근이 가능합니다. Set은 순서와 중복이 없는 자료구조입니다. Map은 Key-Value 형태의 자료구조이며 순서가 없고, Key에 대해 중복이 없습니다.
List에는 ArrayList, LinkedList가 있고, Set에는 HashSet, LinkedHashSet, TreeSet이 있습니다. Map은 HashMap, LinkedHashMap, TreeMap이 있다.
Set과 Map은 List에 비해 검색 속도가 빠르다는 장점이 있습니다.
```

5. Stack과 Queue에 대해 설명하고, 각각의 예시를 설명해주세요.  
```
Stack과 Queue 모두 선형 자료구조로 Stack은 LIFO(후입선출), Queue는 FIFO(선입선출)의 특징을 갖습니다. 스택은 top에서 삽입, 삭제가 일어나고 DFS나 재귀에서 사용됩니다. 또한 함수의 호출 스택이나, 웹 브라우저 뒤로가기 등에 이용됩니다. 큐는 프로세스의 스케줄링과 BFS나 캐시의 구현에 사용됩니다.
```

6. Priority Queue(우선순위 큐)에 대해 설명해주세요. Queue와는 어떻게 다른가요?  
```
우선순위 큐는 각 요소가 우선순위를 가지며, 큐에서 요소를 꺼낼 때 우선순위가 높은 요소가 먼저 나오는 자료 구조입니다. 이는 일반적인 큐와 달리 요소가 추가된 순서와 상관없이 우선순위에 따라 처리됩니다.
```

7. Priority Queue(우선순위 큐)의 동작 원리와 구현 방법에 대해 설명해주세요.  
```
우선순위 큐는 삽입 시 큐 생성 시 부여되는 우선순위 계산 방법을 기준으로 큐 내부의 원소를 정렬합니다. 또한 원소를 꺼낼 시 우선순위가 제일 높은 원소를 꺼내게 되고 정렬되어 있기 때문에 시간 복잡도가 O(1)입니다. 구현은 Heap을 통해 이루어집니다.
```

8. Heap 자료구조에 대해 설명해주세요.  
```
Heap은 완전 이진 트리를 기초로 하는 자료구조로, 주로 우선 순위 큐를 구현하는데 사용됩니다. 최대힙은 부모노드의 값이 자식 노드의 값보다 크거나 같으며 최소힙은 그 반대입니다. 또한 부분적으로만 정렬된 상태를 유지하기 때문에, 효율적으로 연산을 수행할 수 있습니다. 삽입과 삭제의 시간 복잡도는 O(log n)입니다.
```

9. 트리와 그래프의 차이에 대해서 설명할 수 있나요?  
```
트리는 사이클이 없는 연결된 그래프이며, 루트 노드를 제외한 모든 노드가 정확히 하나의 부모 노드를 가지는 구조입니다. 그래프는 노드와 간선으로 구성된 구조로, 사이클이 있을 수도 있고, 노드가 여러 부모를 가질 수도 있습니다. 따라서 트리는 그래프의 특별한 형태로, 더 제한적이고 계층적인 관계를 표현합니다.
```

10. 그래프를 구현할 수 잇는 방법에 대해 설명해주세요.  
```
그래프를 구현할 수 있는 방법은 인접 행렬과 인접리스트가 있습니다. 인접 행렬은 2차원 배열을 사용하여 그래프를 표현 하며 메모리 사용은 많지만 간선 유무를 O(1)로 확인이 가능합니다. 인접 리스트는 각 정점에 인접정점의 리스트를 저장하는 방식으로 간선 추가과 삭제가 빠르다는 특징이 있습니다.
```

11. BST(Binary Search Tree)와 Binary Tree에 대해 설명해주세요.  
```
Binary Tree는 그래프의 한 종류로, 모든 노드가 둘 이하의 자식을 가진 트리의 한 종류입니다.
BST는 Binary Tree의 한 종류로, 부모를 기준으로 작은 노드는 왼쪽, 큰 노드는 오른쪽에 배치하는 Tree입니다.
```

12. 이진 탐색 트리는 어떤 문제점이 있고 이를 해결하기 위한 트리 중 한 가지를 설명해주세요.  
```
이진 탐색 트리는 노드의 삽입과 삭제의 과정에서 트리의 균형이 깨질수 있습니다. 극단적으로 노드의 수가 트리의 높이가 되어 O(n)의 탐색시간을 가질 수 있습니다. 이를 해결하기위해 균형이진탐색트리응 사용할 수 있습니다. 그중 AVL트리는 삽입 삭제시 트리의 균형을 위해 회전을 사용하여 각 노드의 서브트리 높이 차이를 1로 유지하여 O(log n)을 유지할 수 있습니다.
```

13. Red Black Tree와 AVL Tree에 대해 설명해주세요.  
```
두 트리 모두 이진탐색 트리의 불균형 문제를 해결하기 위한 방법입니다.
Red Black Tree는 각 노드를 Red와 Black으로 구분해서 삽입, 삭제 시 Red 노드가 두 개 연속해서 오게 된다면 삼촌 노드의 색에 따라 Recoloring 혹은 Restructuring을 진행해 균형을 맞춥니다.
AVL 트리는 왼쪽과 오른쪽의 높이의 차를 이용해 각기 다른 Rotation 방법을 통해 균형을 맞춥니다.
```

14. Hash Map과 Hash Table의 차이점에 대해 설명해주세요.  
```
둘 다 해시 기반의 데이터 구조지만, Hash Map은 동기화되지 않아 멀티스레드 환경에서는 별도의 동기화가 필요합니다. 반면, Hash Table은 Java에서 동기화된 구조로, 멀티스레드 환경에서도 안전하게 사용할 수 있습니다. 또한, Hash Map은 null 키와 값을 허용하는 반면, Hash Table은 둘 다 허용하지 않습니다. 이러한 차이로 인해 Hash Map이 더 유연하고 성능이 좋지만, Hash Table은 멀티스레드 환경에서 안전합니다.
```

15. 해시 테이블(Hash Table)과 그 시간 복잡도에 대해 설명해주세요.  
```
해시 테이블은 Key-Value 형태로 데이터를 저장하는 자료구조입니다.
검색속도가 빠르다는 특징이 있으며, 이는 내부적으로 해시함수(임의의 데이터를 고정 길이의 데이터로 매핑하는 함수)를 사용하기 때문입니다. 배열(버킷, 슬롯, 공간)을 미리 확보하여 데이터를 저장하여 공간효율성은 떨어집니다.
각 Key 값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 O(1)의 시간 복잡도로 데이터를 조회합니다. 하지만 index 값이 충돌한 경우 Chanining에 연결된 리스트까지 검색해야 하므로 O(n)까지 증가할 수 있습니다.
```

16. Hash Collision (해시 충돌)에 대해 설명할 수 있나요? 해결 방법은 뭐가 있을까요?  
```
서로다른 데이터가 같은 해시 값을 가지게 되는 것이 해시 충돌입니다. 해시 충돌이 자주 발생하면 테이블 성능이 안 좋아질 수 있습니다.
이를 해결하기위한 방법은 Open Addressing(개방 주소법)과 Chaining(체이닝)입니다.
Open Addressing은 충돌이 발생한 경우, 다른 빈 슬롯을 찾아 데이터를 저장하는 방법입니다. 선형탐사, 제곱탐사, 더블해싱 등이 있습니다.
Chaining은 충돌 발생 시 연결리스트로 노드를 추가해 데이터를 저장하여 중복을 제거하는 방법입니다. 주로 구현이 간단한 체이닝을 사용합니다.
```


<br> 

## 알고리즘

1. 시간복잡도와 공간복잡도가 무엇인지 설명해주세요.
```
시간 복잡도란 특정 크기의 입력을 기준으로 할 때 필요한 연산의 횟수를 나타내고,
공간 복잡도란 프로그램 실행과 완료에 얼마나 많은 공간(메모리)가 필요한지를 나타냅니다.
둘 다 알고리즘의 성능이나 효율을 나타내는 척도로 사용되며,
주로 최악의 경우를 고려하는 빅오표기법(Big-O notation)을 사용하여 나타냅니다.
```

2. 시간복잡도와 공간복잡도가 높은 경우 취할 수 있는 일반 전략을 각각 간단히 설명해주세요. 
```
시간복잡도가 높을 경우 코드 최적화를 통해 불필요한 연산을 제거하거나 효율적인 알고리즘으로 변경을 하는 방안이 있습니다. 또는 메모이제이션을 사용하여 불필요한 계산을 줄이거나, 병렬처리를 통해 작업을 동시에 수행하도록 할 수 있습니다.
공간복잡도가 높을 경우 데이터 구조 최적화를 통해 필요한 데이터만 저장하여 메모리 효율이 좋은 자료구조를 사용하도록 할 수 있습니다. 또는 객체를 재사용하여 메모리 할당과 해제를 줄이는 메모리 풀링 방식이나 데이터를 압축하는 전략을 사용해 메모리 사용을 줄일 수 있습니다.
```

3. 동적 계획법(DP, Dynamic Programming)에 대해 설명해주세요. 동적 계획법이 갖는 2가지 조건은 무엇인가요?
```
동적 계획법은 문제를 더 작은 하위 문제로 나누어 해결하고, 그 결과를 저장하여 중복 계산을 피하는 알고리즘 기법입니다. 동적 계획법이 효과적으로 작동하려면, 문제의 최적 해결 방법이 하위 문제의 최적 해결 방법으로 구성될 수 있다는 최적 부분 구조와 동일한 하위 문제가 여러 번 반복된다는 중복 부분 문제라는 두 가지 조건을 만족해야 합니다.
```

4. 다양한 정렬 방법이 있는데, 알고있는 방법에 대해 간단히 설명해주세요.
```
키 값을 비교해 자료를 삽이하는 선택 정렬, 버블 정렬, 퀵 정렬, 병합 정렬 등의 방법이 있고, 계수 정렬과 같이 값을 비교하지 않고 정렬하는 방법도 있습니다.
```

5. 본인이 사용하는 언어의 정렬 알고리즘에 대해 말해주세요.
```
제가 주로 사용하는 언어는 Java입니다. Java에서 Array의 정렬에는 Pivot이 두 개인 퀵 소트를 사용하고, Collections의 정렬 알고리즘은 팀 소트를 사용합니다.
```

6. 이분탐색이 무엇이고 시간복잡도는 어떻게 되며 그 이유는 무엇인가요?
```
이분 탐색은 정렬된 배열에서 특정 값을 효율적으로 찾기 위해 사용하는 알고리즘으로, 탐색 범위를 절반으로 줄여가며 값을 찾습니다. 시간 복잡도는 O(log n)이며, 이는 각 단계에서 탐색 범위를 절반으로 줄이기 때문입니다. 이로 인해 매우 빠르게 값을 찾을 수 있습니다.
```

7. BFS와 DFS에 대해 설명해주세요.
```
그래프를 탐색하는 방법입니다.
BFS는 너비 우선 탐색으로 시작 노드와 인접한 주변 노드 먼저 탐색하고 멀리 떨어진 노드를 나중에 방문하는 순회 방법입니다. 
BFS는 큐를 이용하여 구현하며, 노드 사이의 최단 또는 임의의 경로를 찾을 때 사용합니다.
DFS는 깊이 우선 탐색으로 시작 노드에서 다음 분기로 넘어가기 전까지 해당 분기를 최대한 깊게 탐색하는 순회 방법을 말합니다.
DFS는 스택 또는 재귀함수로 구현하며, 모든 노드를 방문하는 경우 사용되고 그래프 구조 파악에 유용합니다.
```

8. 그래프의 최단경로를 구하는 방법과 구현방법에 대해 간단하게 말해주세요.
```
그래프의 최단 경로를 구하는 대표적인 알고리즘으로는 다익스트라 알고리즘과 벨만-포드 알고리즘이 있습니다. 다익스트라 알고리즘은 가중치가 비음수일 때 효율적이며, 우선순위 큐와 배열을 사용해 구현합니다. 벨만-포드 알고리즘은 음수 가중치가 있을 때 사용하며, 모든 간선을 반복적으로 탐색하여 최단 경로를 찾습니다.
```

9. MST(최소 신장 트리)와 구현방법에 대해 설명해주세요.
```
최소 신장트리는 주어진 그래프에서 최소 개수의 간선을 사용한 가중치의 합이 가장 작은 트리를 의미합니다.
MST를 만드는 방법에는 두 가지 알고리즘이 존재하는데, 첫 번째는 크루스칼 알고리즘입니다. 전체 간선들 중 가중치가 가장 작은 값부터 사이클이 생기지 않게 탐욕적으로 선택하는 방법입니다. 두 번째는 프림 알고리즘으로, 정점 하나를 선택해서 사이클이 생기지 않는 노드 중 가중치가 가장 적은 노드로 다음 목적지를 선택해 나가는 방법입니다.
```

10. 허프만 코딩에 대해 설명해주세요.
```
데이터 압축을 수행하는 알고리즘입니다. 문자의 빈도 수를 가지고 압축하는 과정입니다. 전체 문자를 우선순위 큐에 넣고 빈도수가 낮은 값을 합쳐 이진 탐색 트리를 만들고, 이걸 다시 우선순위 큐에 넣어 N번 반복합니다.
```

11. 최대 공약수와 최소 공배수 알고리즘을 설명해주세요.
```
최대공약수는 유클리드 호제법을 사용하여 구현할 수 있고, 최소공배수는 최대공약수를 이용해 구현할 수 있습니다.
2개의 자연수 a와 b가 있을 때, a와 b를 나눈 나머지를 r이라고 한다면, a와 b의 최대공약수와 b와 r의 최대공약수는 같습니다. 이 성질에 따라 b가 0이 되기 전까지 a와 b를 b와 r로 반복하며 최대공약수를 구할 수 있습니다.
최소공배수는 a와 b의 곱을 a와 b의 최대공약수로 나눈 값입니다.
```

12. 피보나치 수열을 구현하는 방식과 각 방식의 시간 복잡도에 대해 설명해주세요.
```
피보나치 수열은 반복문, 재귀, DP(메모이제이션)로 구현할 수 있습니다.
반복문은 O(N), 재귀는 O(N^2), DP는 O(N)의 시간복잡도를 갖습니다.
```