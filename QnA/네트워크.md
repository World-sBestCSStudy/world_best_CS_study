# 네트워크

- **Q1. OSI 7계층에 대해 설명해주세요** <br>


- **Q2. TCP와 UDP에 대해서 설명해주세요** <br>
TCP는 연결형 서비스로 3-way handshaking 과정을 통해 연결을 진행하며 4-way handshaking 과정을 통해 연결을 해제합니다. <br>
또한, 흐름 제어를 통해 데이터 처리 속도를 조절하며 혼잡 제어를 통해 네트워크 내의 패킷 수가 과도하게 증가하지 않도록 방지합니다.  <br>
그렇기 때문에 높은 신뢰성을 보장하지만 속도가 비교적 느리다는 단점이 있습니다.  <br>
UDP는 비연결형 서비스로 3-way handshaking을 사용하지 않기 때문에 신뢰성이 떨어지는 단점이 있습니다.   <br>
하지만 수신 여부를 확인하지 않기 때문에 속도가 빠릅니다.  <br>
이러한 특성 때문에 TCP는 신뢰성이 중요한 파일 전송과 같은 경우에 쓰이고, UDP는 실시간성이 중요한 스트리밍에 자주 사용됩니다.


- **Q3. TCP의 연결과 끊는 과정에 대해서 설명해주세요.** <br>


- **Q4. TCP의 연결 과정과 연결 종료 과정 단계가 차이나는 이유가 뭔가요?**  <br>


- **Q5. UDP는 항상 신뢰성을 보장하지 않나요??**  <br>


- **Q6. 흐름제어와 혼잡제어가 무엇인가요?** <br>
흐름제어는 수신 측이 송신 측보다 데이터 처리 속도가 빠르면 문제가 없지만, 송신 측의 속도가 빠를 경우 문제가 생깁니다.   <br>
수신 측에서 제한된 저장 용량을 초과한 이후에 도착하는 패킷은 손실될 수 있으며, 만약 손실된다면 불필요한 추가 패킷 전송이 발생하게 됩니다.   <br>
즉, 송신 측과 수신 측의 TCP 버퍼 크기 차이로 인해 생기는 데이터 처리 속도 차이를 해결하기 위한 기법입니다.  <br>
혼잡제어는 데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 초과된 데이터는 라우터가 처리하지 못합니다.   <br>
이때 송신 측에서는 라우터가 처리하지 못한 데이터를 손실 데이터로 간주하고 계속 재전송하여 네트워크를 혼잡하게 합니다.   <br>
이런 상황에 송신 측의 전송 속도를 적절히 조절하여 이러한 현상을 예방하는 기법입니다.  <br>
즉, 흐름 제어는 송수신 측 사이의 패킷 수를 제어하는 기능이라 할 수 있으며, 혼잡 제어는 네트워크 내의 패킷 수를 조절하여 네트워크의 오버플로우를 방지하는 기능입니다. 


- **Q7. 흐름제어와 혼잡제어를 하는 방법이 뭐가있을까요?** <br>


- **Q8. HTTP와 HTTPS에 대해서 설명해주세요** <br>


- **Q9. HTTPS의 동작 과정이 어떻게 되나요?** <br>


- **Q10. HTTP/1.1과 HTTP/2의 차이에 대해서 설명해주세요.** <br>


- **Q11. 비대칭키(공개키) 암호화와 대칭키 암호화에 대해 설명해주세요.** <br>


- **Q12. 로드 밸런싱(Load Balancing) 에 대해 말해보세요.** <br>


- **Q13. 서버 확장의 두 가지 방법(Scale-Up, Scale-Out) 에 대해 설명해보세요.** <br>


- **Q14. 로드 밸런싱 알고리즘 중 대표적인 라운드 로빈, 최소 연결 방식 에 대해 설명해보세요.** <br>
라운드 로빈(Round Robin) 알고리즘은 서버에 들어오는 요청들을 순서대로 돌아가면서 배정하는 알고리즘입니다.   <br>
뭐가되었든 하나씩 배정하기 때문에 여러 대의 서버 성능이 비슷하고 세션이 오래 지속되지 않는 경우에 적합합니다.  <br>
반면, 최소 연결 방식(Least Connection Method) 은 요청이 서버에 들어왔을 때 가장 연결이 적은 서버에 배정하는 알고리즘입니다.   <br>
서버 트래픽이 일정하지 않고 세션이 길어질 때 적합합니다.  <br>
이 외에도 서버마다 가중치를 매겨 가중치에 맞게 요청을 배정하는 가중 라운드 로빈 방식, 클라이언트의 IP주소를 해싱하여 분배하는 IP 해싱 방식,   <br>
서버의 현재 연결 상태와 응답 시간을 고려하여 배분하는 최소 리스폰 타임 알고리즘이 있습니다.


- **Q15. Blocking/Non-Blocking과 sync/async의 차이에 대해 설명하세요** <br>
Blocking/Non-Blocking은 프로세스의 제어권과 관련된 개념이고, sync/async는 작업 완료 여부에 대한 개념입니다.  <br>
Blocking은 특정 작업이 실행될 때, 제어권을 함께 넘겨주며 작업이 끝나야 제어권을 돌려받고, Non-Blocking은 특정 작업에게 실행 명령만 내리고, 제어권은 곧바로 다시 돌려받습니다.  <br>
sync는 순차적으로 작업을 수행하기 때문에, 특정 작업이 완료될 때까지 대기하며 결과를 받은 뒤에 다음 작업을 수행합니다.   <br>
반면, async는 특정 작업의 완료 여부와 상관없이 다음 작업을 수행하며, 완료 순서가 보장되지 않습니다.  <br>
이와 관련해서 프로젝트를 진행하면서 가상 쓰레드를 통해 Non-Blocking 비동기 방식으로 서비스를 구현함으로써 기존의 Blocking 방식에서 발생할 수 있는 컨텍스트 스위칭 비용을 줄이고  <br>
서비스의 처리 속도를 개선 시킨 경험이 있습니다.


- **Q16. www.google.com에 접속할 때 생기는 과정을 네트워크 관점에서 설명해 주세요.**  <br>
