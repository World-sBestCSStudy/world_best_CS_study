# CPU 스케줄링

다중 프로그래밍의 목적 → **CPU 이용률을 최대화**하기 위해 항상 실행 중인 프로세스를 가지게 함. 어떤 프로세스가 대기 중이라면, 운영체제는 CPU를 그 프로세스로 부터 회수해서 다른 프로세스에 할당한다.

### I/O 버스트 사이클

프로세스의 실행은 **CPU 실행**과 **I/O 대기**의 사이클로 구성

### CPU 스케줄러

- CPU 가 유휴 상태(사용 가능한 상태이나 실제적인 작업이 없는 시간)가 될 때마다, 운영체제는 Ready Queue에 있는 프로세스 중 하나를 선택해서 실행해야 한다. 선택 절차가 CPU 스케줄러에 의해 수행된다.
- CPU 스케줄러는 실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택해, CPU를 할당한다.
- Ready Queue는 반드시 FIFO 방식의 큐가 아닌, 우선순위 큐, 트리 등으로 구현될 수 있다.
- 일반적으로 큐에 있는 레코드들은 프로세스의 프로세스 제어 블록이다.

### 선점 및 비선점 스케줄링

- 대기 상태 : 프로세스가 특정 이벤트가 발생하기를 기다리는 상태 → 예시 : 파일을 읽거나 쓰기 위한 디스크 입출력을 기다리는 경우
- 실행 상태 : 프로세스가 현재 CPU를 사용하여 명령어를 실행하고 있는 상태
- 준비 완료 상태 : 프로세스가 실행될 준비가 되어 있지만, 현재 CPU를 사용할 수 없는 상태

CPU 스케줄링의 결정은 다음의 네 가지 상황에서 발생할 수 있다.

1. 한 프로세스가 실행 상태에서 대기 상태로 전환될 때 ( I/O 발생 )
2. 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때 ( 인터럽트 발생 )
3. 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때 ( I/O 종료 )
4. 프로세스가 종료될 때

**비선점 스케줄링**에서는, 일단 CPU가 한 프로세스에 할당되면 프로세스가 종료하든지, 또는 대기 상태로 전환해 CPU를 방출할 때까지 점유한다. ( 1, 4 번 )

**선점 스케줄링**에서는 시분할 시스템에서 타임 슬라이스가 소진되었거나, 인터럽트나 시스템 호출 종료시에 더 높은 우선 순위 프로세스가 발생 되었음을 알았을 때, 현 실행 프로세스로부터 강제로 CPU를 회수하는 것을 말한다. ( 2, 3 번 )

데이터가 다수의 프로세스에 의해 공유될 때 racing condition(경쟁 상태)이 발생될 수 있다.

뮤텍스, 모니터 등의 기법을 사용해 경쟁 상태를 피한다.

인터럽트는 어느 시점에서든지 발생할 수 있으므로, 코드가 실행되는 도중에도 발생할 수 있습니다. 예를 들어, 변수의 값을 수정하는 도중에 인터럽트가 발생하면, 인터럽트 서비스 루틴이 실행되고 그 변수에 접근할 수 있습니다. 이로 인해 데이터 불일치나 예상치 못한 동작이 발생할 수 있습니다.

**인터럽트**? 하드웨어나 소프트웨어가 CPU에게 특정 이벤트를 처리하도록 요청하는 신호입니다. 인터럽트가 발생하면 CPU는 **현재 실행 중인 작업을 멈추고**, **인터럽트 서비스 루틴(ISR)이 호출되어 해당 이벤트를 처리**합니다. 이 과정에서 **CPU는 현재 작업 상태를 저장**하고, 인터럽트 처리 후에는 **저장된 상태를 복원하여 원래 작업을 계속**합니다.

### 디스패처

CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 주는 모듈

하는 일 ?

- 한 프로세스에서 다른 프로세스로 문맥을 교환
- 사용자 모드로 전환
- 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동

디스패처가 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는데까지 소요되는 시간을 **디스패치 지연(dispatch latency)이라고 한다.**

**문맥 교환은 자발적 문맥 교환과 비자발적 문맥 교환으로 나뉜다.**

- **자발적 문맥 교환:** 현재 사용 불가능한 자원을 요청했을 때 프로세스가 CPU 제어를 포기한 경우 발생
- **비자발적 문맥 교환:** 타임 슬라이스가 만료되었거나 우선순위가 더 높은 프로세스에 의해 선점되는 경우와 같이 CPU를 빼앗겼을 때 발생

**문맥교환?**

운영 체제에서 여러 프로세스를 효율적으로 실행하기 위해 CPU가 한 프로세스에서 다른 프로세스로 전환될 때 발생하는 작업

프로세스의 실행 상태를 저장하고, 새로운 프로세스의 실행 상태를 로드하는 과정

**문맥 교환의 비용**

문맥 교환은 CPU 시간과 메모리 리소스를 소모합니다. 문맥 교환이 자주 발생하면 시스템의 전체 성능에 부정적인 영향을 미칠 수 있다.

### 스케줄링 기준

**CPU 스케줄링 비교 기준**

- **CPU 이용률(Utilization)**: 어느 기간 동안 또는 특정 SNAPSHOT에서의 CPU의 이용률을 말한다.
- **처리량(Throughput)**: 단위 시간당 완료된 프로세스의 개수로써 나타낼 수 있다.
- **총처리 시간(Turnaround Time)**: 프로세스의 제출 시간과 완료 시간의 간격을 총처리 시간이라고 한다.
- **대기 시간(Waiting Time)**: 대기 시간은 프로세스가 준비 큐에서 대기하면서 보낸 시간의 합이다.
- **응답 시간(Response Time)**: 하나의 Request를 제출한 후 첫 번째 Response가 나올 때까지의 시간이다.

CPU 이용률과 처리량을 최대화하고, 총 처리 시간과 대기 시간, 응답 시간을 최대화 해야한다.

하지만 대부분의 알고리즘의 경우는 Trade-Off ( 모순적 관계 ) 임으로 본인의 Context에 맞춰서 선택하는 것이 가장 좋은 방법이다.

# 스케줄링 알고리즘

### 선입 선처리 스케줄링 (FCFS)

CPU를 먼저 요청하는 프로세스가 CPU를 먼저 받음 ( 그냥 큐 )

- 평균 대기 시간이 종종 엄청 길 수 있다. ( ⇒ 실행 시간이 긴 프로세스가 CPU를 독점하게 되면 뒤따르는 프로세스들이 모두 대기해야 한다. )
- 비선점형 알고리즘이다.

### 최단 작업 우선 스케줄링 (SJF)

CPU 버스트 길이가 가장 작은 프로세스부터 순차적으로 CPU 코어를 할당

- 최소의 평균 대기 시간을 가진다.
- 각 프로세스의 CPU 버스트 길이는 알 수 있는 방법이 없어서 예측해서 스케줄링 해야한다.
- 선점형, 비선점형 둘다 가능하다. 비선점형일 경우 앞의 프로세스가 실행되는 동안 새로운 프로세스가 준비 큐에 도착하면 선택이 발생한다.

### 라운드 로빈 스케줄링 (RR)

선입 선처리 스케줄링과 유사하지만 시스템이 프로세스들 사이를 옮겨다닐 수 있도록 선점이 추가된다.

- 시간 할당량 또는 타임 슬라이스라고 하는 작은 단위의 시간을 정의한다.
- CPU 스케줄러는 준비 큐를 돌면서 한 번에 한 프로세스에 한 번의 시간 할당량 동안 CPU를 할당한다.

시간 할당량 크기에 많은 영향을 받는다. 매우 큰 경우 FCFS와 유사해진다. 반대로 매우 적다면 매우 많은 문맥 교환을 야기한다.

### 우선순위 스케줄링

우선순위가 각 프로세스들에 연관되어 있으며, CPU 코어는 가장 높은 우선순위를 가진 프로세스에 할당된다.

- 우선 순위는 내부적 외부적으로 정의될 수 있다.
- 선점형, 비선점형 모두 가능하다.
- 주요 문제는 **무한 봉쇄 or 기아 상태** 이다. ( 봉쇄는 기아 상태의 원인 )
  - 실행 준비는 되어 있으나 CPU를 사용하지 못하는 프로세스는 CPU를 기다리면서 봉쇄 된 것으로 간주할 수 있다. (Blocking)
  - 부하가 과중한 컴퓨터 시스템에서는 높은 우선순위의 프로세스들이 꾸준히 들어와서 낮은 우선순위의 프로세스들이 CPU를 얻지 못하게 될 수 도 있다. (Starvation)
- 낮은 우선순위 프로세스들의 무한 봉쇄를 해결할 방법은 노화이다.
  - ⇒ 오랫동안 시스템에 대기하는 프로세스들의 우선순위를 점진적으로 증가시킨다.
- 또 다른 해결방법은 우선순위 스케줄링과 라운드 로빈 스케줄링을 결합한다

### 다단계 큐 스케줄링

**우선순위 스케줄링이 라운드 로빈과 결합한 스케줄링 알고리즘**

프로세스를 여러 개의 큐로 나누어 관리하는 CPU 스케줄링 알고리즘

- 각 큐는 서로 다른 우선순위를 가지며, 각 큐는 서로 다른 스케줄링 알고리즘을 사용할 수 있습니다.
- 프로세스의 성격에 따라 다르게 처리할 수 있도록 하여, 시스템의 응답성과 효율성을 높이는 데 도움이 됩니다.

**단점**:

- **복잡성**: 여러 큐와 각 큐의 스케줄링 알고리즘을 관리하는 것은 복잡할 수 있습니다.
- **불공평성**: 낮은 우선순위 큐의 프로세스는 높은 우선순위 큐에 의해 오랫동안 대기할 수 있습니다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e3e78d12-2dc1-4f0e-b156-d02e7bb67166/f2badfa4-71de-497f-881b-f0ed8686a02f/Untitled.png)

### 다단계 피드백 큐 스케줄링

프로세스가 큐들 사이를 이동하는 것을 허용한다.

- 다단계 피드백 큐 스케줄링 알고리즘은 기아 상태를 예방한다.
- 프로세스는 특정 조건에 따라 큐들 사이를 이동할 수 있습니다. 예를 들어, CPU 할당량(time slice)을 초과하거나, 오랜 시간 대기한 경우(노화) 큐를 이동합니다.
- **시간 할당량 초과**: 높은 우선순위 큐에서 지정된 시간 할당량을 초과하는 프로세스는 낮은 우선순위 큐로 이동합니다. 이를 통해 CPU가 특정 프로세스에 지나치게 오래 할당되지 않도록 합니다.
- **대기 시간 증가**: 낮은 우선순위 큐에서 오랜 시간 대기한 프로세스는 높은 우선순위 큐로 이동하여 실행 기회를 얻습니다.

[출처] [https://imbf.github.io/computer-science(cs)/2020/10/18/CPU-Scheduling.html](<https://imbf.github.io/computer-science(cs)/2020/10/18/CPU-Scheduling.html>)
