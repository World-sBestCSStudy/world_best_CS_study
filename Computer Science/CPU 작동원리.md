## CPU 작동원리

### CPU구성

![https://taegyunwoo.github.io/assets/img/2023-01-26-Interview_CPU/Untitled.png](https://taegyunwoo.github.io/assets/img/2023-01-26-Interview_CPU/Untitled.png)

- **ALU**
  - ALU는 레지스터에 저장된 데이터를 이용하여 덧셈, 곰셈 등과 같은 산술 연산을 수행
- **Control Unit**
  - 명령어를 순서대로 실행할 수 있도록 제어하는 장치이다.즉 컴퓨터 전체를 작동시키는 엔진 역할을 한다.
  - 주기억장치에서 프로그램 명령어를 꺼내 해독하고, 그 결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력장치 로 보낸다.
  - 여러 장치가 보낸 신호를 받아, 다음에 수행할 동작을 결정한다.
- **레지스터**
  - 명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장한다.
  - 용도에 따라 범용 레지스터 와 특수목적 레지스터 로 구분된다.
    - 범용 레지스터 : 연산에 필요한 데이터나 연산 결과를 임시로 저장하는 레지스터
    - 특수목적 레지스터 : 특별한 용도로 사용하는 레지스터
  - 주요 특수목적 레지스터
    - **MAR (메모리 주소 레지스터)**
      - 읽기와 쓰기 연산을 수행할 주기억장치의 주소를 저장한다.
      - 시스템 버스 중 하나인 **주소 버스 에 연결된 유일한 레지스터**이다.
      - 따라서 주소 정보를 가져올 때, 무조건 MAR을 사용해야 한다.
    - **PC (프로그램 카운터)**
      - 다음에 수행할 명령어의 주소를 저장한다.
    - **IR (명령어 레지스터)**
      - 현재 실행 중인 명령어를 저장한다.
    - **MBR (메모리 버퍼 레지스터)**
      - 주기억장치에서 읽어온 데이터 혹은 저장할 데이터를 임시로 저장한다.
    - **AC (누산기)**
      - 연산 결과를 임시로 저장한다.

### CPU 동작과정

1. 주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램 읽어 온다.
2. CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억장치에 저장한다.
3. 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 보낸다.
4. 제어장치는 1~3 과정에서 명령어가 순서대로 실행되도록 각 장치를 제어한다.

**명령어 사이클**

- CPU가 주기억장치에서 한번에 하나의 명령어를 인출하여 실행하는데 필요한 일련의 활동
- 인출(Fetch) 단계, 간접(Indirect) 단계, 실행(Execute) 단계, 인터럽트(Interrupt) 단계
- 주기억장치의 지정된 주소에서 하나의 명령어를 가져오고, 실행 사이클에서는 명령어를 실행한다.하나의 명령어 실행이 완료되면 그 다음 명령어에 대한 인출 사이클 시작

![https://velog.velcdn.com/images/dlgosla/post/f1959a5e-0e47-4b55-8bbd-f9f6005cc323/image.png](https://velog.velcdn.com/images/dlgosla/post/f1959a5e-0e47-4b55-8bbd-f9f6005cc323/image.png)

**인터럽트**

- 어떠한 예외가 발생하여, 기존의 프로세스가 중단된 상태
- 인터럽트를 처리하기 위해, **인터럽트 서비스 루틴 (ISR) 을 호출**한다.
  - 인터럽트 서비스 루틴 (ISR) : 인터럽트를 처리하기 위한 명령어들의 모음
- 인터럽트가 처리되었다면, 다시 “인출” 전단계로 돌아간다.

![https://taegyunwoo.github.io/assets/img/2023-01-26-Interview_CPU/Untitled 1.png](<https://taegyunwoo.github.io/assets/img/2023-01-26-Interview_CPU/Untitled 1.png>)

**명령어 세트**

CPU가 실행할 명령어의 집합 → 연산 코드(Operation Code) + 피연산자(Operand)

- 연산 코드
  - 실행할 연산, 연산, 제어, 데이터 전달, 입출력 기능을 가짐
- 피연산자
  - 필요한 데이터 or 저장 위치, 주소, 숫자/문자, 논리 데이터 등을 저장

### 명령어 인출

- `PC`에 저장된 주소를 `MAR(기억 장치 주소 레지스터)`로 전달
- 저장된 내용을 토대로 주기억장치의 해당 주소에서 명령어 인출
- 인출한 명령어를 `MBR(기억장치 버퍼 레지스터)`에 저장
- 다음 명령어를 인출하기 위해 `PC` 값 증가시킴
- `MBR`에 저장된 내용을 명령어 레지스터(IR)에 전달

```nasm
T0 : MAR ← PC
T1 : MBR ← M[MAR], PC ← PC+1
T2 : IR ← MBR
```

### 명령어 실행 과정

EX ) `ADD AC, B`

1. `IR` 에 저장된 **“Operand(피연산자)인 B 데이터가 저장된 주소”** 를 `MAR` 로 전달
2. ‘`MAR` 로 옮겨진 B의 주소’로 주기억장치에 접근하여, B 데이터를 `MBR` 로 전달
3. `AC + B` 연산 결과를 `AC` 에 저장

```nasm
T0 : MAR ← IR(Addr)
T1 : MBR ← M[MAR]
T2 : AC ← AC + MBR
```

### 인터럽트 처리 과정

1. 현재 수행 중인 프로그램 실행을 중단하고, 그 문맥 (context) 를 저장한다.
   - 문맥 : 현재 수행 중인 상태 (`PC` , `연산결과` 등의 값)
2. `PC` 에 인터럽트 처리기 루틴 (`ISR`)의 시작주소를 세팅한다.
   - `PC` 에는 항상 다음 명령어의 주소가 저장된다.
   - 인터럽트를 처리하기 위해 `ISR` 이 다음에 수행되어야 하므로, `PC` 에 `ISR` 의 시작주소를 세팅해야 한다.
3. `ISR` 을 수행하며 인터럽트를 처리한다.
4. `ISR` 을 모두 처리한 후, 문맥을 복원하고 인터럽트된 기존 프로그램을 다시 수행한다.

### 인터럽트가 필요한 이유

- **인터럽트가 없는 경우**
  ![https://taegyunwoo.github.io/assets/img/2023-01-26-Interview_CPU/Untitled%203.png](https://taegyunwoo.github.io/assets/img/2023-01-26-Interview_CPU/Untitled%203.png)
  →CPU는 무조건 모든 작업을 **순차적으로(동기적으로) 수행**해야 한다. 따라서 I/O 장치가 작업을 마칠 때까지 기다린 후, 다음 작업을 수행한다.
- **인터럽트가 있는 경우**
  ![https://taegyunwoo.github.io/assets/img/2023-01-26-Interview_CPU/Untitled%204.png](https://taegyunwoo.github.io/assets/img/2023-01-26-Interview_CPU/Untitled%204.png)
  → 인터럽트가 있다면, CPU가 비동기적으로 작업을 할 수 있다.
  ex) **I/O 장치에게 일을 맡기고** 다음 작업을 이어서 수행할 수 있다. 만약 I/O 장치의 작업이 종료되면, **인터럽트를 통해 CPU에게 이 사실을 알려주고, 필요한 추가 작업(인터럽트 처리)을 먼저 수행**할 수 있다.

---

### 질문

Q) 인터럽트가 필요한 이유를 설명하세요

A)인터럽트가 없는 경우 모든 작업을 동기적(순차적)으로 수행해야해서 비효율적입니다. 인터럽트를 통해 CPU가 비동기 적으로 작업하게 할 수 있습니다. 예를 들어 I/O 장치에게 일을 맡기고 다음 작업을 이어서 수행할 수 있습니다.. 만약 I/O 장치의 작업이 종료되면, 인터럽트를 통해 CPU에게 이 사실을 알려주고, 필요한 추가 작업(인터럽트 처리)을 먼저 수행할 수 있습니다.
