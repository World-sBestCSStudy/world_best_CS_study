# 비트마스크

## 비트마스크 : BitMask

→ 비트마스크는 정수의 이진수 표현을 자료 구조로 쓰는 기법

### 비트마스크를 사용했을 때 장점?

1. 수행 시간이 빠르다
2. 코드가 짧다
3. 메모리 사용량이 더 적다.

   bit 가 10개인 경우 , 2^10 가지의 경우를 10bit 이진수로 표현이 가능

### 비트 연산자

비트마스크를 사용하기 위해, 비트 연산자를 사용한다.

- AND 연산
  `&` → 둘 다 1일 때 1
- OR 연산
  `|` → 둘 다 0일 때 0
- XOR 연산
  `^` → 둘 중 하나만 1일 때
- NOT 연산
  `~` → 반대로
- shift 연산
  `<<` , `>>` → 비트 들을 왼쪽 또는 오른쪽으로 원하는 만큼 움직인다. 빈자리는 0으로 채운다. 1101 >> 1 = 0110

### 주의할 점

- 비교 연산자보다 우선 순위가 낮다.
  6 & 4 == 4 → 6 & 1
- 오버플로우
  자료형의 크기 보다 큰 결과가 나오게 될 때

### 비트마스크를 이용한 집합 구현

“하나의 bit가 하나의 원소”를 의미하게 한다.

bit 가 켜져 있으면 해당 원소가 집합에 포함되어 있다는 의미

N비트 정수 변수라면 N개의 원소를 갖는 집합의 **부분 집합들을 모두 표현**할 수 있다.

N개의 boolean 원소를 갖는 배열 선언 → 정수 하나로 표현 가능

예시 ) A라는 변수를 집합이라 가정하고, 집합의 총 원소의 개수를 10개로 가정 ( 0번째 ~ 9번째 )

- 공집합 : A = 0
- 꽉 찬 집합 : A = (1 << 10) -1
- 원소 추가 : A |= (1<<k);
  k번째 원소를 추가하기 or 연산은 하나라도 1이면 1 k번째가 존재한다.를 or 연산
- 원소 삭제 : A &= ~(1 << k)
  k만 0인 비트를 and 연사나 해서 k 번째만 0으로 바꾸기
- 원소의 포함 여부 확인 : if(A & (1 << k))
  K가 1인 곳과 & 연산으로 1인지 확인하기
- 원소의 토글 : A ^= ( 1 << k )
  원소가 빠져 있다면 추가 , 들어가 있다면 삭제
- 두 집합의 연산
  ```
  A | B       → A와 B의 합집합
  A & B     → A와 B의 교집합
  A & (~B) → A에서 B를 뺀 차집합
  A ^ B     → A와 B중 하나에만 포함된 원소들의 집합
  ```
- 집합 크기 구하기 ( 집합에 포함된 원소 수 ) → 해당 수가 가지는 1의 비트 수 구하기
  ```
  int bitCount(int A){
    if(A == 0) return 0;
    return A%2 + bitCount(A / 2);
  }
  ```
  5
  1 + bitCount(2)
  0 + bitCount(1)
  1 + bitCount(0)
  1 + 0 + 1 + 0 = 2
  5의 true 비트는 2개이다. 101
  - 자바에서는 **`Integer.bitCount`** 를 사용하면 된다.
- 최소 원소 찾기 : int first = A & (-A)
  집합에 포함된 가장 작은 원소(index 가 가장 작은 원소) 찾기
  켜져 있는 bit 중에서 가장 오른쪽에 있는 bit 를 찾는 것
  → 펜윅 트리 에서도 사용되는 기법
  11000
  -A는 ~A + 1이다. → ~A + 1 은 가장 오른쪽의 켜져 있던 bit가 1이되고 오른쪽 나머지는 0이된다
  11000 & 01000 → 해당 자리 수를 제외한 모든 수는 0이 된다.
  01000 이 정답
- 최소 원소 지우기 : A &= (A -1)
  11000 & 10111 = 10000
  10010 & 10001 = 10000
  10001 & 10000 = 10000
  → 1을 빼면 가장 오른쪽에 있던 bit는 0이 되고 그보다 오른쪽에 있는 모든 bit들이 1이 되기 때문에
- 모든 부분 집합 순회하기 : for ( int subset = A ; subset ; subset = ((subset-1)&A)){}

[ 출처:https://rebro.kr/63 ]
