### 🤷‍♀️ NoSql?
기존 RDBMS를 탈피한 데이터베이스<br>
관계형 테이블과 다른 형식으로 데이터를 저장하는 비관계형 데이터베이스 유형을 가리킴

**종류**
- 서로 연관된 그래프 형식의 데이터를 저장할 수 있는 Graph Store
- Row가 아닌 Column 위주로 데이터를 저장하는 Column Store
- 비정형 대량 데이터를 저장하기 위한 Document Store
- 메모리 기반으로 빠르게 데이터를 읽어올 수 있는 Key-Value Store

<br>

## Redis
![redis](./assets/image.png)

가장 인기있는 Key-Value Store로 ***Re***mote ***Di***ctionary ***S***erver의 약자. (원격 Dictionary 자료구조 서버)

DB, cache, session storage, message broker로 사용되며 인메모리 데이터 구조를 가진 저장소 → 디스크 기반의 RDBMS보다 read 속도가 빠르다.
> ➕ Message Broker(메시지 브로커)는 Publisher(송신자)로부터 전달받은 메시지를 Subscriber(수신자)로 전달해주는 중간 역할이며 응용 소프트웨어 간에 메시지를 교환할 수 있게 한다. 이 때 메시지가 적재되는 공간을 Message Queue(메세지 큐)라고 하며 메시지의 그룹을 Topic(토픽)이라고 한다.

<br>

### 캐시 서버로서의 Redis
보통의 RDBMS는 디스크에 직접 접근하여 쓰기 때문에 서버가 다운되더라도 데이터 손실이 없다는 장점이 있는 반면, 매번 디스크에 접근해야 하기 때문에 사용자가 많아질수록 부하가 증가하여 속도가 느려질 수 있다는 단점이 있다. 그래서 **사용자가 증가**하게 되면 캐시 서버(**cache server**)를 도입해서 사용하는데, 이런 캐시 서버로 이용할 수 있는 것이 바로 Redis이다. 여러번 같은 요청이 들어올 경우, 첫번째 요청 이후 캐시 서버에 저장된 값을 바로 내려주기 때문에 **DB의 부하를 줄이고 속도가 빠르다.**

하지만 모든 데이터를 캐시에 저장하게되면 용량이 부족할 수 있다. 그래서 Redis에서 캐시를 다룰 때 적절한 ***캐시 배치 전략***을 세운다. 적절한 **캐시 읽기 전략**(Read Cache Strategy)과 **캐시 쓰기 전략**(Write Cache Strategy)을 통해, 캐시와 DB간 데이터 불일치 문제(**데이터 정합성**)를 극복하면서 **속도**도 유지할 수 있다.

- 캐시 읽기 전략: Look Aside 패턴, Read Through 패턴
- 캐시 쓰기 전략: Write Back 패턴, Write Through 패턴, Write Around 패턴

참고: [[REDIS] 📚 캐시(Cache) 설계 전략 지침 💯 총정리](https://inpa.tistory.com/entry/REDIS-📚-캐시Cache-설계-전략-지침-총정리)

<br>

## Redis의 특징
- 인메모리 구조로 속도가 빠르다.
- Key-Value 구조로 쿼리를 사용할 필요가 없다.
    - Key의 자료형: 기본적으로 String
    - Value의 자료형: String(text, binary data. 512MB까지 저장 가능), List(양방향 연결리스트도 가능), Set(String 집합), Sorted Set(Set을 정렬한 것), Hash를 지원한다.
- 싱글 스레드(Single Thread)로 한 번에 하나의 명령만 처리가 가능하기 떄문에 뒤에 들어온 명령어들은 앞선 명령어의 처리가 끝날 때까지 대기가 필요하다. (하지만, Get, Set 명령어의 경우 초당 10만개 이상 처리할 수 있을 정도로 빠르다.)

<br>

### Redis 사용 시 주의점
- 서버에 장애가 발생할 경우에 대한 운영 플랜이 꼭 필요하다. (인메모리 특성상 데이터 유실 우려)
- 메모리 관리가 중요하다.
- 처리 시간이 오래 걸리는 요청, 명령은 피해야한다. (싱글 스레드 특성상 하나의 명령어만 처리할 수 있기 때문)
- 메모리를 적당히 여유있게 사용하는 것이 좋다. 메모리 파편화를 신경쓰지 않으면 실제 물리 메모리가 커져 프로세스가 죽는 현상이 나타날 수 있다. 또한 쓰기 연산이 copy on write 방식으로 동작하여 최대 메모를 2배 이사악지 사용하기도 한다.

<br>

### DBMS로서의 Redis
다양한 영속성(디스크에 백업) 옵션을 제공하기 때문에 DB로서 사용 가능하다.

또한 Java에서 다루기 까다로운 여러 기능을 DBMS로서 갖추고 있다.
- TTL 설정: 일정 시간 이후 데이터 삭제. 용량이 작은 메모리의 효율적인 관리
- 분산 데이터 저장소 구성: Redis Cluster 등 분산환경에서 안정적인 데이터 관리 가능
- 보안체계: 악성 스크립트 공격으로부터 안전 보장. TLS 지원

<br>

## Redis 트랜잭션
Redis는 일반적으로 인메모리로 이루어져 있어서 캐시의 형태로 많이 사용

Redis에 트랜잭션이 안 맞지않냐 생각할 수 있지만, 여러 자료구조를 사용할 수 있는 Redis의 특성상 트랜잭션을 잘 이용하면 더 유용하게 다양한 상황에서 Redis를 사용할 수 있다고 한다.

### 어떻게?
트랜잭션을 유지하기 위해서는 순차성을 가져야 하고 도중에 명령어가 치고 들어오지 못하게 Lock이 필요합니다. Redis에서는 **MULTI, EXEC, DISCARD 그리고 WATCH** 명령어를 이용

참고: [[redis] 트랜잭션(Transaction) - 이론편](https://sabarada.tistory.com/177)

<br>

<br>


## ❓ 면접질문
**Q. 레디스에 대해 설명해주세요**
```
관계형 데이터베이스가 아닌 key-value 형식의 비관계형 데이터베이스 중 하나입니다. DB나 캐시, 세션 스토리지, 메세지브로커 등으로 사용이 됩니다. 인메모리 구조를 가져 디스크 방식의 DB에 비해 속도가 빠르다는 장점이 있습니다. 
또한 싱글 스레드 방식으로 동작하여 처리에 긴 시간이 걸리는 작업은 부적합합니다.
```

<br>

**Q. 레디스 사용경험이 있다면 이야기 해주세요.**

<br>

**Q. 자바의 해쉬맵과 레디스가 어떻게 다른가요?**
```
A. 레디스와 자바의 해쉬맵은 둘다 key-value 기반의 메모리 베이스라는 공통점을 가집니다. 서버가 1대일 경우 성능 차이가 없어보일 수 있습니다. 하지만 분산 환경에서 해쉬맵은 원격 프로세스간 데이터 동기화가 힘든 반면, 레디스를 활용하게되면 빠른 응답성과 더불어 데이터 불일치 문제를 해결할 수 있습니다. 또한 해쉬맵은 어플리케이션 종료 시에 휘발되어 사라지지만, 레디스는 다양한 영속성(디스크에 백업) 옵션을 제공합니다.
```

<br>

참고: https://wildeveloperetrain.tistory.com/21, https://sihyung92.oopy.io/database/redis/1, https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-%EA%B0%9C%EB%85%90-%EC%86%8C%EA%B0%9C-%EC%82%AC%EC%9A%A9%EC%B2%98-%EC%BA%90%EC%8B%9C-%EC%84%B8%EC%85%98-%ED%95%9C%EB%88%88%EC%97%90-%EC%8F%99-%EC%A0%95%EB%A6%AC?category=918728#%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84