# 인덱스

**목적**: RDBMS에서 검색 속도를 높이기 위한 기술. Table의 Column을 색인화 함 (따로 파일로 저장).

- 해당 Table의 Record를 Full scan 하지 않음
  - Full scan ? 테이블의 모든 행을 처음부터 끝까지 하나씩 검사하는 것을 의미
  - 필요한 데이터가 있는 위치를 바로 찾을 수 있다.
- 색인화 된 (B+ Tree 구조로) Index 파일 검색으로 검색 속도 향상.
  - B+ Tree 구조? 데이터를 정렬된 순서로 저장하며, 빠른 검색, 삽입, 삭제가 가능
  - 색인화? 컬럼의 값을 B+ Tree 구조로 저장, 특정 값 검색 시 트리 특성으로 빠르게 접근

**과정**: Table을 생성하면, MYD, MYI, FRM 3개의 파일이 생성됨.

- FRM: 테이블 구조가 저장되어 있는 파일.
- MYD: 실제 데이터가 있는 파일.
- MYI: Index 정보가 들어가 있는 파일.

Index를 사용하지 않는 경우, MYI 파일은 비어져 있음. 그러나, 인덱싱하는 경우 MYI 파일이 생성됨. 이후에 사용자가 Select 쿼리로 Index를 사용하는 Column을 탐색 시, MYI 파일의 내용을 검색함.

**장점**

- 검색 성능 향상: Table의 모든 데이터를 검색하지 않고 Index를 통해 빠르게 데이터를 조회할 수 있음.
- 특정 쿼리의 성능 최적화: Where 절, Join 절, Order by 절 등에서 효율적으로 사용 가능.
  - 인덱스가 이미 정렬된 구조를 가지고 있어서 빠르게 Order by도 사용 가능
- 중복 데이터 방지: Unique Index를 사용하면 중복된 데이터를 입력하지 않도록 할 수 있음. ( 예시 : `CREATE UNIQUE INDEX idx_unique_email ON users(email);` )

**단점**

- Index 생성 시, .mdb 파일 크기가 증가함.
- 한 페이지를 여러 사용자가 동시에 수정할 수 있는 병행성이 줄어듬.
  - 페이지? 데이터베이스에서 데이터를 저장하는 최소 단위 블록
  - 동시에 여러 사용자가 같은 페이지에 있는 데이터를 수정하려고 하면, 인덱스 갱신으로 위한 락이 추가로 걸려서 병행성이 줄어들게 됨
- 인덱스 된 Field에서 Data를 업데이트하거나, Record를 추가 또는 삭제 시 성능이 떨어짐.
- 데이터 변경 작업이 자주 일어나는 경우, Index를 재작성해야 하므로, 성능에 영향을 미침.
- 추가적인 저장 공간 필요: Index 파일을 저장하기 위한 추가적인 디스크 공간이 필요.

### **사용하면 좋은 경우**

1. Where 절에서 자주 사용되는 Column.
2. 외래키가 사용되는 Column.
3. Join에 자주 사용되는 Column.
4. 데이터 검색 속도가 중요한 경우.
5. 특정 패턴의 데이터를 자주 조회하는 경우.

### **Index 사용을 피해야 하는 경우**

1. Data 중복도가 높은 Column. ( ⇒ 인덱스가 특정 값을 가리키는 행이 너무 많아짐 , 인덱스를 사용해도 많은 행을 검사해야함 )
2. DML이 자주 일어나는 Column. ( ⇒ DML ( = ‘INSERT’, ‘UPDATE’, ‘DELETE’ 등 ) )
3. 매우 작은 테이블: Full scan이 빠를 수 있음.
4. 인덱스 크기가 테이블 크기와 비슷할 때: 오히려 성능 저하 유발 가능.

### DML이 일어났을 때의 상황

### **INSERT**

1. **기존 Block에 여유가 없을 때, 새로운 Data가 입력됨**:
   - **블록(Block)**: 데이터베이스는 데이터를 블록이라는 단위로 저장합니다. 하나의 블록에는 여러 행(row)이 들어갈 수 있습니다.
   - 데이터가 삽입될 때, 현재 블록에 여유 공간이 없다면 새로운 블록을 할당받아 데이터를 저장합니다.
2. **새로운 Block을 할당 받은 후, Key를 옮기는 작업을 수행**:
   - 새로운 블록에 데이터를 저장하면, 인덱스도 이 새로운 데이터를 가리켜야 합니다. 이 과정에서 인덱스에 있는 키 값들이 재정렬되거나 이동해야 할 수 있습니다.
   - **Redo 기록**: 이러한 작업은 많은 양의 로그 기록을 남깁니다. 데이터베이스는 모든 변경 사항을 기록하여 복구할 수 있도록 하는데, 이를 Redo 로그라고 합니다. 많은 변경이 발생하면 로그의 양도 많아집니다.
3. **Index split 작업 동안, 해당 Block의 Key 값에 대해서 DML이 블로킹 됨... 대기 이벤트 발생**:
   - **Index split 작업**: B+ Tree와 같은 인덱스 구조에서는 특정 노드(블록)에 데이터가 꽉 차면 이를 두 개로 나누는 작업이 필요합니다. 이를 "split"이라고 합니다.
   - split 작업이 진행되는 동안, 해당 인덱스 노드에 대한 모든 DML 작업(삽입, 수정, 삭제)은 일시적으로 중지됩니다. 이로 인해 대기 이벤트가 발생할 수 있습니다.

### **DELETE**

1. **Table에서 data가 delete 되는 경우**:
   - **Table**에서 데이터를 삭제하면, 해당 데이터가 실제로 지워지고, 그 공간은 다른 데이터가 사용할 수 있게 됩니다.
2. **Index에서 Data가 delete 되는 경우**:
   - 인덱스에서는 삭제된 데이터를 실제로 지우지 않고, "사용되지 않음" 표시만 합니다. 즉, 데이터를 논리적으로만 삭제하고 물리적으로는 그대로 남아 있습니다.
   - **문제**: 이렇게 하면, 테이블의 데이터 수와 인덱스의 데이터 수가 달라질 수 있습니다. 이는 인덱스가 비효율적으로 사용되는 원인이 될 수 있습니다.

### **UPDATE**

1. **Table에서 update가 발생하면 -> Index는 Update 할 수 없음**:
   - 테이블에서 데이터를 업데이트할 때, 인덱스는 직접적으로 업데이트되지 않습니다. 대신, 인덱스에서는 기존 데이터를 삭제하고 새로운 데이터를 삽입하는 방식으로 처리합니다.
2. **Index에서는 Delete가 발생한 후, 새로운 작업의 Insert 작업 / 2배의 작업이 소요되어, 힘듬**:
   - **Delete 후 Insert**: 인덱스에서는 업데이트를 위해 먼저 기존 데이터를 논리적으로 삭제한 후, 새로운 데이터를 삽입합니다. 이는 두 배의 작업이 필요합니다.
   - 예를 들어, `UPDATE users SET email = 'new_email@example.com' WHERE id = 1;` 쿼리를 실행하면, 인덱스는 `email` 컬럼의 기존 값을 삭제하고 새로운 값을 삽입해야 합니다. 이로 인해 성능이 저하될 수 있습니다.

**Index의 유형**

**1. B-Tree Index**

- 일반적으로 가장 많이 사용됨.
- 정렬된 순서로 데이터를 저장하여 검색 속도가 빠름.

**2. Hash Index**

- 특정 조건에 빠르게 접근할 수 있지만, 범위 검색에는 부적합.
- 주로 정확한 값 일치 검색에 사용됨.

**3. Bitmap Index**

- 낮은 카디널리티( 다양한 고유값이 특정 컬럼에 많이 존재함 ) 의 데이터에 적합.
- 각 값을 비트맵으로 변환하여 저장.

**4. Full-text Index**

- 텍스트 데이터의 검색에 사용됨.
- 단어의 출현 빈도와 위치를 기반으로 검색.

**Index 유지 보수**

- **Rebuild Index**: 단편화된 인덱스를 재구성하여 성능을 최적화. ( DML이 자주 일어나면 데이터가 연속된 블록에 저장되지 못하고 흩어지게 됨)
- **Analyze Index**: 인덱스 통계를 수집하여 쿼리 최적화에 사용.
- **Drop Index**: 불필요한 인덱스를 삭제하여 성능 최적화.

**인덱스 활용을 극대화하기 위한 팁**

- 필요한 컬럼에만 인덱스를 생성하여 성능 저하를 방지.
- Composite Index를 사용하여 다중 컬럼 검색 성능을 최적화.
- 인덱스를 주기적으로 모니터링하고, 불필요한 인덱스는 제거.
- 데이터 삽입/삭제 작업이 빈번한 테이블은 인덱스를 신중하게 관리.
