# 트랜잭션

### DB 트랜잭션(Transaction)

**트랜잭션이란?**

- **정의**: 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위.
- **상태 변화**: SQL 질의어를 통해 DB에 접근하는 것. 예를 들어, `SELECT`, `INSERT`, `DELETE`, `UPDATE` 등의 명령을 사용합니다.
- **작업 단위**: 여러 SQL 명령문을 묶어서 하나의 작업 단위로 정의하는 것.

**예시**: 사용자 A가 사용자 B에게 만원을 송금하는 경우

- 사용자 A의 계좌에서 만원을 차감한다. (UPDATE 문을 사용해 사용자 A의 잔고를 변경)
- 사용자 B의 계좌에 만원을 추가한다. (UPDATE 문을 사용해 사용자 B의 잔고를 변경)

이 두 개의 UPDATE 문을 하나의 트랜잭션으로 묶습니다.

- 이 두 작업이 모두 성공해야 트랜잭션이 완료됩니다. 이를 `Commit`이라고 합니다.
- 하나라도 실패하면 모든 작업을 취소하고 이전 상태로 되돌립니다. 이를 `Rollback`이라고 합니다.

### 트랜잭션의 특징 (ACID 특성)

1. **원자성(Atomicity)**:
   - 트랜잭션이 DB에 모두 반영되거나, 전혀 반영되지 않아야 합니다. 즉, 트랜잭션이 하나의 단위로 완료되거나 전혀 이루어지지 않는 것을 보장합니다.
2. **일관성(Consistency)**:
   - 트랜잭션의 작업 처리 결과는 항상 일관성을 유지해야 합니다. 데이터베이스가 무결성 제약 조건을 만족하도록 보장합니다.
3. **독립성(Isolation)**:
   - 둘 이상의 트랜잭션이 동시에 실행될 때, 각 트랜잭션은 다른 트랜잭션의 영향을 받지 않아야 합니다. 즉, 트랜잭션 간의 간섭을 방지합니다.
4. **지속성(Durability)**:
   - 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 반영되어야 합니다. 시스템 장애가 발생하더라도 트랜잭션의 결과가 유지됩니다.

### 트랜잭션 관련 명령어

- **Commit**: 하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성 있는 상태임을 확인한 후 변경 내용을 영구적으로 저장하는 연산.
- **Rollback**: 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션의 원자성이 깨진 경우, 트랜잭션이 시작된 상태로 되돌리는 연산.

### 트랜잭션 관리를 위한 DBMS의 전략

**DBMS의 구조**

1. **Query Processor**: 질의 처리기. SQL 명령어를 분석하고 실행 계획을 수립합니다.
2. **Storage System**: 저장 시스템. 데이터를 저장하고 관리합니다.

### Page Buffer Manager (버퍼 관리자)

**역할**: 버퍼 관리자는 데이터베이스 시스템에서 메인 메모리에 유지되는 페이지를 관리하는 역할을 합니다. 버퍼 관리자는 디스크 I/O를 최소화하고 메모리 활용을 최적화하기 위해 중요한 역할을 합니다.

### Buffer 관리 정책

버퍼 관리 정책에 따라 데이터베이스 시스템은 트랜잭션 관리에 필요한 UNDO와 REDO 작업을 결정합니다. 버퍼 관리 정책은 수정된 데이터를 언제 디스크에 기록할지를 결정하는데, 크게 두 가지 기준으로 나뉩니다: steal과 ¬steal, FORCE와 ¬FORCE.

### UNDO

**필요한 이유**: 트랜잭션이 정상적으로 종료되지 않았을 때, 이미 수정된 데이터를 원래 상태로 되돌리기 위해 필요합니다. 이는 트랜잭션이 실패했을 때 데이터의 일관성을 유지하는 데 중요합니다.

**정책**:

- **steal**: 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책.
  - 대부분의 DBMS가 이 정책을 채택합니다.
  - 트랜잭션이 완료되지 않았더라도, 메모리에서 디스크로 페이지를 기록할 수 있습니다. 이는 메모리의 효율적 사용을 위해 필요합니다.
  - **UNDO 로그**: 이 정책을 사용할 때는 트랜잭션이 실패했을 경우를 대비해 UNDO 로그가 필요합니다. UNDO 로그는 원래 데이터를 기록하여 필요시 이를 복구할 수 있도록 합니다.
- **¬steal**: 수정된 페이지를 트랜잭션이 끝날 때까지 메모리에 유지하는 정책.
  - 수정된 페이지는 트랜잭션이 완료될 때까지 디스크로 기록되지 않습니다.
  - 이로 인해 트랜잭션 실패 시 UNDO 작업이 필요하지 않습니다.
  - 그러나 큰 메모리 버퍼가 필요합니다. 메모리 공간이 제한적일 경우 비효율적일 수 있습니다.

### REDO

**필요한 이유**: 이미 커밋된 트랜잭션의 변경 내용을 영구적으로 반영하기 위해 필요합니다. 이는 시스템 장애 후에도 데이터의 일관성을 유지하는 데 중요합니다.

**정책**:

- **FORCE**: 트랜잭션이 커밋될 때 수정된 모든 페이지를 디스크에 반영하는 정책.
  - 트랜잭션이 커밋되면 그 시점에 모든 변경 내용을 디스크에 기록합니다.
  - 커밋된 후에 시스템이 중단되더라도 REDO 작업이 필요 없습니다.
  - 그러나, 커밋 시점마다 디스크 I/O가 발생하여 성능에 영향을 미칠 수 있습니다.
- **¬FORCE**: 커밋 시점에 디스크에 반영하지 않는 정책.
  - 트랜잭션이 커밋될 때, 변경된 내용을 반드시 디스크에 기록하지 않습니다.
  - 커밋된 변경 내용이 디스크에 반영되지 않을 수 있으므로, 시스템 장애 후 REDO 작업이 필요합니다.
  - 대부분의 DBMS가 이 정책을 사용합니다. 이는 성능 최적화를 위해 커밋 시점의 디스크 I/O를 줄이기 위함입니다.

### 요약

- **UNDO**: 트랜잭션이 실패했을 때 변경된 데이터를 원래 상태로 되돌리는 작업.
  - **steal**: 언제든지 수정된 페이지를 디스크에 쓸 수 있어 UNDO 로그 필요.
  - **¬steal**: 트랜잭션이 끝날 때까지 메모리에 유지하여 UNDO 작업 불필요.
- **REDO**: 커밋된 트랜잭션의 변경 내용을 영구적으로 반영하는 작업.
  - **FORCE**: 커밋 시점에 모든 변경 내용을 디스크에 기록하여 REDO 작업 불필요.
  - **¬FORCE**: 커밋 시점에 디스크에 기록하지 않아 REDO 작업 필요.

## 면접 질문

### 💡 트랜잭션이란 무엇인지 설명해주세요.

트랜잭션은 작업의 완전성을 보장해줍니다.
즉, 작업들을 모두 처리하거나 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능입니다.
하나의 트랜잭션은 Commit(작업완료)되거나 Rollback(취소)됩니다.

### 💡 트랜잭션의 특성(ACID)에 대해 설명해주세요.

1. 원자성(Atomicity) 작업이 모두 반영되던지 아니면 전혀 반영되지 않아야 한다.
2. 일관성(Consistency) 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 한다.
3. 독립성(Isolation) 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다.
4. 영속성(Durability) 완료된 결과는 영구적으로 반영되어야 한다.
