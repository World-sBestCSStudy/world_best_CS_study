# 옵저버 패턴

- 한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는 패턴이다.
- 한 객체의 상태 변화를 추적하고 이에 따른 처리를 여러 곳에서 수행해야 하는 경우 유용하다.

### 구현 방법
1. Subject(주제): 상태를 관찰하고 알림을 보내는 주체 객체입니다.
2. Observer(옵저버): 주제의 상태 변화를 관찰하고 통지를 받는 객체입니다.
3. ConcreteSubject(구체적인 주제): 실제로 상태를 가지고 있고, 상태가 변경될 때 옵저버들에게 알리는 주제의 구체적인 구현입니다.
4. ConcreteObserver(구체적인 옵저버): 실제로 상태 변화를 감지하고 처리하는 옵저버의 구체적인 구현입니다.

```
public class Singleton {
    // 유일한 인스턴스를 저장하기 위한 정적 변수
    private static Singleton instance;
    
    // 생성자를 private으로 선언하여 외부에서 인스턴스를 생성하지 못하도록 함
    private Singleton() {
        // 생성자 내용
    }
    
    // 유일한 인스턴스에 접근할 수 있는 정적 메서드
    public static Singleton getInstance() {
        // 인스턴스가 없는 경우에만 인스턴스 생성
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### 면접 질문
- **싱글톤 디자인을 활용하는 경우를 예를 들어 설명해주세요.** <br>
싱글톤 패턴은 특정 용도로 인스턴스를 하나만 생성하여 전역으로 이용하고 싶을 때 사용합니다.
예를 들어 설정 정보를 관리하는 클래스가 있을 때 여러 모듈에서 인스턴스를 생성하게 되면 각 모듈마다 설정 정보가 달라져 일관성을 해칠 수 있습니다.
이러한 경우 싱글톤 패턴을 이용하여 인스턴스를 한 번만 생성하고 전역으로 공유하여 사용한다면
문제의 발생과 불필요한 메모리 낭비를 방지할 수 있습니다.


- **싱글턴 디자인 패턴의 장단점을 설명해주세요.** <br>
싱글톤 패턴의 장점으로는 불필요한 메모리 낭비를 방지하고 전역 인스턴스를 통해 쉽게 자원공유를 할 수 있다는 점이 있습니다.
반면에 단점으로는 전역으로 접근을 허용하기 때문에 해당 인스턴스에 의존하는 경우 결합도가 증가할 수 있습니다.
이 경우 의존성 주입을 통해 결합도를 느슨하게 만들어줄 수 있습니다.
