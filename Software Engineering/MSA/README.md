# Microservice Achitecture 

여러개의 ``독립적``으로 배포 가능한 각각의 기능을 수행하는 서비스로 구성된 프레임워크 

### 등장 배경 ?
MSA 가 도입되기 전 Monolithic 아키텍처 방식으로 개발이 이루어졌다. 모든 기능을 하나의 어플리케이션에서 비즈니스 로직을 구성해 운영하였다 
개발이나 환경설정에 있어서 간단하다는 장점이 있지만 시스템이 확장 될 수록 단점들이 생겨났다. 

모놀리식의 장점 
- **초기 개발에 유리**: 빠르게 프로토타입 개발이 가능하다.
- **직접적인 기능 호출**: 필요한 모든 기능을 한 번만 호출하기 때문에 복잡한 통신 없이 직접 사용할 수 있다.

모놀리식의 단점 
- **빌드/테스트 시간의 증가** : 하나를 수정해도 시스템 전체를 빌드해야 한다 ( 시간 소요 ), 유지 보수의 힘듬 
- **작은 문제가 시스템 전체의 문제를 일으킴** : 만약 하나의 서비스 부분에 트래픽 문제로 서버가 다운되면, 모든 서비스가 이용이 불가해짐. 
- **확장성의 불리** : 서비스마다 이용률이 다를 수 있는데, 하나의 서비스를 확장하기 위해 전체 프로젝트를 확장해야한다. 
- **한 프레임워크와 언어에 종속적**: 전체 시스템이 하나의 기술 스택에 묶여 있어, 다른 기술을 도입하기 어렵다.

## MSA 의 등장과 장점 

Microservice Architecture의 장점

- **독립적 배포 가능**: 각 서비스가 독립적으로 배포될 수 있어, 한 서비스의 업데이트나 수정이 전체 시스템에 영향을 미치지 않는다.
- **개발 속도 향상**: 개발팀이 특정 서비스에 집중할 수 있어, 개발 속도가 빨라진다.
- **유연한 확장성**: 각 서비스가 독립적으로 확장될 수 있어, 필요에 따라 유연하게 리소스를 할당할 수 있다.
- **향상된 장애 격리**: 한 서비스의 장애가 다른 서비스로 확산되지 않으므로, 시스템 전체의 안정성이 높아진다.
- **기술 다양성**: 각 서비스가 독립적이기 때문에, 서비스마다 최적의 기술 스택을 사용할 수 있다.

Microservice Architecture의 단점과 다양한 해결 방법 

1. 서비스 별로 호출 시 API로 통신하므로 속도가 느리다.
- **비동기 통신**: 요청과 응답이 동시에 이루어지지 않도록 하여, 비동기적으로 처리할 수 있는 부분은 비동기 메시징 시스템 (예: RabbitMQ, Kafka) 을 사용한다.
- **캐싱**: 반복적으로 요청되는 데이터에 대해서는 캐싱을 사용하여 응답 시간을 줄인다. Redis, Memcached와 같은 인메모리 데이터 저장소를 사용할 수 있다.
- **API Gateway 최적화**: API Gateway를 통해 요청을 집계하고, 공통 기능(인증, 로깅, 모니터링 등)을 처리하여 각 서비스의 부하를 줄인다.
    - 로드밸런싱 : 들어오는 트래픽을 여러 서비스 인스턴스에 고르게 분배하여 서버 부하 관리 
    - 보안 기능 통합 : 인증, 권한 부여, 데이터 암호화 등의 보안 기능을 API Gateway에서 처리 ( ex : JWT ) 
    - 모니터링 및 로깅 : 모든 요청과 응답을 로깅하여, 성능 병목이나 오류를 감지하여 대응하기
    - 트래픽 제한 및 QoS 정책(서비스 품질 : 네트워크 상에서 데이터의 중요도에 따라 처리 ) 을 적용해 서비스 안정성 높이기
- **gRPC 사용**: JSON을 사용하는 RESTful API 대신, 바이너리 형식의 gRPC를 사용하여 통신 성능을 향상시킨다.

2. DB 또한 개별적으로 운영되어 트랜잭션으로 묶기 힘들다 -> 분산 트랜잭션 관리
   (분산 트랜잭션은 두 개 이상의 독립적인 데이터베이스나 시스템에서 트랜잭션을 처리하는 것을 의미합니다. 예를 들어, 한 서비스에서 시작된 트랜잭션이 다른 서비스의 데이터베이스 변경을 포함할 때 이를 분산 트랜잭션이라고 합니다.)
- **Sagas 패턴**: 장기 실행 트랜잭션을 여러 단계로 나누어 처리하고, 각 단계가 성공적으로 완료되면 다음 단계로 진행하는 방식이다. 실패 시 보상 트랜잭션을 실행하여 이전 상태로 되돌린다.
- **이벤트 소싱**: 데이터 상태를 이벤트의 시퀀스로 저장하여, 이벤트 스트림을 재생해 현재 상태를 복원한다. 이벤트 기반 아키텍처로 구현하여 각 서비스가 독립적으로 트랜잭션을 처리하도록 한다.
- **최종 일관성**: 모든 시스템이 즉각적으로 일관성을 유지하기보다는, 일정 시간이 지난 후에 일관성을 유지하도록 설계한다. 이는 일관성 유지를 위한 동기화 작업이 줄어서 성능과 확장성을 향상시킨다.
- **분산 잠금**: 여러 서비스가 동시에 동일한 리소스를 수정하지 않도록, 분산 잠금 메커니즘 (예: Redis 분산 잠금)을 사용하여 데이터 일관성을 유지한다. ( 외에도 Zookeeper, Consul등을 활용 가능 )

# 면접 답변
### 질문 1: 모놀리식 아키텍처와 Microservice Architecture의 차이에 대해 말해보세요.
모놀리식 아키텍처와 Microservice Architecture는 소프트웨어 개발 및 배포 방식에서 큰 차이점을 보입니다.
모놀리식 아키텍처는 모든 기능이 하나의 애플리케이션에 통합된 구조입니다. 이 방식의 장점으로는 초기 개발이 빠르고, 복잡한 통신 없이 기능을 직접 호출할 수 있어 성능이 뛰어납니다. 하지만 시스템이 커질수록 빌드와 테스트 시간이 증가하고, 작은 문제도 시스템 전체에 영향을 미칠 수 있습니다. 또한, 특정 기능을 확장하기 위해 전체 애플리케이션을 확장해야 하며, 하나의 프레임워크와 언어에 종속적이어서 기술 스택 변경이 어렵습니다.
반면, Microservice Architecture는 각각 독립적으로 배포 가능한 여러 서비스로 구성된 구조입니다. 각 서비스가 독립적으로 배포되고 관리되기 때문에, 한 서비스의 업데이트나 수정이 전체 시스템에 영향을 미치지 않습니다. 개발팀이 특정 서비스에 집중할 수 있어 개발 속도가 빨라지고, 서비스별로 유연한 확장이 가능합니다. 또한, 한 서비스의 장애가 다른 서비스에 영향을 미치지 않으며, 서비스마다 최적의 기술 스택을 사용할 수 있어 기술 다양성을 제공합니다. 그러나 서비스 간 통신에 따른 지연과 데이터 일관성 유지의 어려움이 있으며, 이를 해결하기 위해 비동기 통신, API Gateway 최적화, gRPC 사용 등 다양한 방법을 도입합니다.

### 질문 2: Microservice Architecture에서 데이터 일관성을 어떻게 유지하나요?
Microservice Architecture에서는 각 서비스가 독립적으로 데이터베이스를 관리하기 때문에 데이터 일관성을 유지하는 것이 도전적입니다. 이를 해결하기 위해 여러 가지 방법을 사용합니다.
첫째, Sagas 패턴을 사용하여 장기 실행 트랜잭션을 여러 단계로 나누어 처리합니다. 각 단계가 성공하면 다음 단계로 진행하고, 실패 시 보상 트랜잭션을 실행하여 이전 상태로 되돌립니다. 이로써 트랜잭션의 일관성을 유지합니다.
둘째, 이벤트 소싱을 통해 상태 변화를 이벤트로 기록하고, 모든 변경 내역을 추적합니다. 이벤트 스트림을 재생해 현재 상태를 복원할 수 있어 데이터의 신뢰성을 확보합니다.
셋째, 최종 일관성 개념을 도입하여 즉각적인 일관성을 요구하지 않고, 일정 시간이 지난 후에 일관성을 유지합니다. 이를 통해 성능과 확장성을 향상시키며, 동기화 작업을 줄여 시스템의 부하를 낮춥니다.
마지막으로, 분산 잠금 메커니즘을 사용하여 여러 서비스가 동시에 동일한 리소스를 수정하지 않도록 합니다. Redis, Zookeeper, Consul 등을 활용해 데이터 일관성을 보장합니다.