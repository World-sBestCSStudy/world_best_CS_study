# 스레드

### 스레드란?

하나의 프로세스 안에서 독립적으로 실행되는 `작은 실행 단위` 를 의미

### 프로세스란?

시스템에서 실행 중인 프로그램을 의미합니다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e3e78d12-2dc1-4f0e-b156-d02e7bb67166/6d7272f1-8c97-4754-ad6a-15113630acb8/Untitled.png)

Java에서 스레드는 **‘멀티 스레드(Multi-Thread)’을 지원하여 하나의 프로세스 안에 한 개 이상의 스레드를 지원하는 구조**입니다.

Java에서는 멀티 스레드를 통해 ‘비동기식 및 병렬 애플리케이션’을 개발할 수 있습니다

**비동기식 및 병렬 애플리케이션이란?**

애플리케이션이 실행 중인 동안 사용자가 다른 작업을 수행할 수 있도록 합니다. 웹 브라우저에서는 웹 페이지를 로드하는 동안 사용자가 다른 작업을 수행할 수 있습니다. 

**블로킹 (blocking I/O)란?**

I/O가 동작되고 있는 동안에 다른 일을 처리하지 못하는 상태를 의미하며 함수가 모든 일을 마무리될 때까지 다음 처리가 안되는 것을 의미합니다.

**논 블로킹(Non-blocking I/O)란?**

I/O가 동작을 하면서 request를 받으면 바로 다음 처리에 요청을 보내 놓고 다른 작업을 처리하다가 먼저 요청한 작업이 끝나면 이벤트를 받아서 응답을 보내는 것을 의미합니다.

### 스레드의 구조

스레드는 시스템의 하나의 프로세스 공간에서 수행되기에 단일스레드와 멀티스레드로 구분한 구조를 확인합니다.

![단일 스레드](https://prod-files-secure.s3.us-west-2.amazonaws.com/e3e78d12-2dc1-4f0e-b156-d02e7bb67166/47842137-d7f3-4089-95e7-cf6634223822/Untitled.png)

단일 스레드

![멀티 스레드](https://prod-files-secure.s3.us-west-2.amazonaws.com/e3e78d12-2dc1-4f0e-b156-d02e7bb67166/2c03ee40-148e-4bc8-afd6-ee5c38e16bb7/Untitled.png)

멀티 스레드

스레드에서는 **프로세스 내에서 함께 공유**해서 사용하는 영역과 스레드 내의 **공유를 하지 않는 영역**으로 나뉩니다

| 구분 | 설명 | 공유 여부 | 동기회 필요여부 |
| --- | --- | --- | --- |
| Code 영역 | 프로그램 코드 | 공유 | 불필요 |
| Data 영역 | 전역 변수 및 정적 변수 | 공유 | 불필요 |
| Heap 영역 | 동적 할당된 메모리 | 공유 | 필요 |
| Stack 영역 | 지역 변수 및 매개변수 | 비 공유 | 불 필요 |

### Code 영역

- **프로그램의 ‘코드가 저장’되는 영역을 의미합니다.**
- Thread들은 같은 코드 영역을 공유하며 이 영역은 읽기 전용입니다. 따라서 Thread 간에는 이 영역에 대한 동기화가 필요하지 않습니다.

### Data 영역

- **‘전역 변수와 정적 변수가 저장’ 되는데 해당 영역은 ‘프로그램이 실행되고 종료될 때까지 메모리에 존재’하는 영역을 의미합니다.**
- Thread들은 같은 Data 영역을 공유합니다. 이 영역도 읽기 전용이므로 Thread 간에는 Data 영역에 대한 동기화가 필요하지 않습니다. 하지만 여러 Thread가 동시에 쓰는 경우에는 동기화 문제가 발생할 수 있습니다.

전역 변수 : 클래스 내부에서 모든 메서드에서 사용 가능한 변수입니다. 클래스 내부 어디서든 참조 가능하며 클래스가 생성될 때 자동으로 초기화됩니다.

지역 변수 : 지역변수는 메서드나 블록 내에서 선언되는 변수로, 선언된 블록 안에서만 참조 가능합니다. 메서드가 호출될 때 생성되며, 메소드가 종료될 때 소멸됩니다.

### Heap 영역

- **동적 할당된 ‘메모리가 저장’ 되는 영역을 의미합니다.**
- Thread 간에 Heap 영역을 공유합니다. 이 영역은 여러 Thread가 동시에 쓰는 경우 동기화 문제가 발생할 수 있으므로 적절한 동기화 기법을 사용해야 합니다.

### Stack 영역

- **함수 호출 시 생성되는 ‘지역 변수와 매개변수’가 저장되며 함수가 호출되었을 때 임시로 저장되고 ‘함수의 호출이 끝나면 해당 영역의 메모리에서 해제’가 되는 영역을 의미합니다.**
- 이 영역은 Thread 마다 독립적으로 존재하며 Thread 간에 공유되지 않습니다. 따라서, 스택 영역에서는 동기화 문제가 발생하지 않습니다.

자바에서의 스레드 동기화 문제? 

- 스레드는 프로그램이 동시에 여러 작업을 수행할 수 있도록 해주는 기능입니다. 하지만 ‘여러 스레드가 동시에 하나의 자원에 접근하면서 발생하는 문제’가 동기화 문제입니다.
- 스레드는 실행되는 시간이 OS에 의해 관리되기 때문에 어떤 스레드가 먼저 실행될지 예측할 수 없습니다. 따라서 여러 스레드가 동시에 하나의 자원에 접근하면, 결과가 예측할 수 없게 됩니다. 또한, 스레드가 자원에 접근하는 순서에 따라서는 원하는 결과를 얻을 수 없는 경우도 있습니다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e3e78d12-2dc1-4f0e-b156-d02e7bb67166/3d04983d-fb22-4b39-998a-396623d4bbdb/Untitled.png)

### 단일 스레드

- **하나의 프로세스 내에서 하나의 스레드만 실행되는 것을 말합니다(순차 실행). 프로그램이 하나의 작업만 처리할 수 있다는 의미이며, 다른 작업이 실행되기 전에 현재 작업이 완료되어야 합니다.**
- 멀티 태스킹을 지원하지 않고 하나의 태스크만 처리할 수 있으므로 처리량이 낮아지는 단점이 있습니다.

### 멀티 스레드

- **하나의 프로세스 내에서 동시에 여러 개의 스레드가 실행되는 것을 말합니다(병행 실행). 스레드가 동시에 여러 작업을 처리할 수 있기 때문에 시스템의 성능을 향상할 수 있습니다.**
- 프로그램의 작업을 분할하여 처리하기 때문에 다양한 작업을 동시에 처리하여 빠르고 효율적으로 실행할 수 있습니다. 그러나 스레드 간의 동기화 같은 부작용으로 이를 고려하여 프로그래밍해야 합니다.

**💡 단일 스레드보다 멀티스레드가 당연히 좋은 것 아닌가?**

- 멀티스레드는 한 번에 여러 작업을 처리할 수 있지만, 스레드 간의 경쟁으로 인해 자원 공유 및 동기화 문제가 발생할 수 있습니다. 이는 올바르게 처리하지 않으면 예측할 수 없는 결과를 초래할 수 있습니다.
- 반면, 단일 스레드는 하나의 작업을 처리하고 다음 작업으로 이동합니다. 이러한 접근 방식은 자원 공유와 동기화 문제를 방지할 수 있습니다. 또한 단일 스레드의 실행 순서는 예측 가능합니다. 따라서 멀티스레드와 단일 스레드는 각각의 장단점이 있으며, 상황에 따라 선택해야 합니다.

## 스레드 상태

스레드의 상태는 JVM에 의해서 생성 및 관리가 됩니다.

| 열거 상수 (Enum) | 상태 | 설명 |
| --- | --- | --- |
| Thread.State.NEW | 객체 상태 | 스레드가 생성되었지만 아직 start()가 호출되지 않은 상태 |
| Thread.State.RUNNABLE | 실행 대기 | 스레드가 실행 가능한 상태 |
| Thread.State.BLOCKED | 일시 정지 | 스레드가 일시적으로 중단된 상태 |
| Thread.State.WAITING | 일시 정지 | 스레드가 다른 스레드의 특정 작업 완료를 기다리는 상태 |
| Thread.State.TIMED_WAITING | 일시 정지 | 스레드가 일정 시간 동안 기다리는 상태 |
| Thread.State.TERMINATED | 종료 | 스레드가 실행을 완료한 상태 |

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e3e78d12-2dc1-4f0e-b156-d02e7bb67166/7e312f6b-fe90-40a1-bf91-57fedc02b188/Untitled.png)

**💡 [ 스레드 상태 과정 설명]**

1. Thread는 NEW라는 스레드가 생성된 상태로 시작됩니다.

2. Thread는 RUNNABLE이라는 실행이 가능한 상태로 시작이 됩니다.

3. Thread는 실행이 됩니다.

4. Thread는 각각의 상태가 될 수 있습니다.

- BLOCKED : 일시적으로 중단된 상태
- WATING : 다른 스레드가 작업 완료 될 때를 기다리는 상태
- TIMED_WATING : 일정시간 동안 기다리는 상태
- TERMINATED : 실행을 완료한 상태

5. WATING 상태일 때라면, 다른 스레드의 작업을 완료를 기다리는 상태로 Thread B가 수행될 때를 기다립니다.

6. 각각이 상태에서 다시 RUNNABLE 상태로 대기 상태가 됩니다.

### 스레드 메서드

| 메서드 | 설명 |
| --- | --- |
| start() | 스레드를 시작한다. |
| run() | 스레드의 작업을 정의한다. |
| sleep(long millis) | 현재 스레드를 주어진 시간(밀리초)만큼 일시 중지한다. |
| yield() | 현재 스레드를 일시 중지하고 다른 스레드에게 실행 기회를 양보한다. |
| join() | 다른 스레드가 종료될 때까지 현재 스레드를 일시 중지한다. |
| isAlive() | 스레드가 실행 중인지 여부를 반환한다. |
| setName(String name) | 스레드의 이름을 지정한다. |
| getName() | 스레드의 이름을 반환한다. |
| setPriority(int priority) | 스레드의 우선순위를 지정한다. |
| getPriority() | 스레드의 우선순위를 반환한다. |
| interrupt() | 스레드의 작업을 중단시킨다. |

### 스레드 관련 Object 메서드

| 메서드 | 설명 |
| --- | --- |
| wait() | 현재 스레드를 일시적으로 중지시키고, 다른 스레드가 notify() 또는 notifyAll() 메서드를 호출할 때까지 기다리게 합니다. (스레드가 lock을 가지고 있으면, lock 권한을 반납하고 대기하게 만듬) |
| notify() | wait() 메서드에 의해 일시적으로 중지된 스레드 중 하나를 실행 대기 상태로 변경합니다. 여러 개의 스레드가 wait() 중인 경우, 이 중 하나만을 임의로 선택해 실행 대기 상태로 변경합니다. (대기 상태인 스레드에게 다시 lock 권한을 부여하고 수행하게 만듬) |
| notifyAll() | wait() 메서드에 의해 일시적으로 중지된 모든 스레드를 실행 대기 상태로 변경합니다. |

동기화 된 영역(임계 영역)내에서 사용되어야 한다.

```java
/**
* 스레드 동기화 중 협력관계 처리작업 : wait() notify()
* 스레드 간 협력 작업 강화
*/

public synchronized void makeBread(){
    if (breadCount >= 10){
        try {
            System.out.println("빵 생산 초과");
            wait();    // Thread를 Not Runnable 상태로 전환
        } catch (Exception e) {

        }
    }
    breadCount++;    // 빵 생산
    System.out.println("빵을 만듦. 총 " + breadCount + "개");
    notify();    // Thread를 Runnable 상태로 전환
}

public synchronized void eatBread(){
    if (breadCount < 1){
        try {
            System.out.println("빵이 없어 기다림");
            wait();
        } catch (Exception e) {

        }
    }
    breadCount--;
    System.out.println("빵을 먹음. 총 " + breadCount + "개");
    notify();
}
```

### 스레드 실행

**💡 Thread.start()**

- 스레드가 작업을 실행하는데 필요한 콜 스택을 생성한 다음 run()을 호출해서 그 스택 안에 run()을 저장할 수 있도록 해준다.

**💡 Thread.run()**

- 스레드 작업을 정의합니다.

```java
public class ThreadSample extends Thread {

    @Override
    public void run() {
        System.out.println("스레드를 시작합니다.");
    }

    /**
     * Thread의 메인
     *
     * @param args
     */
    public static void main(String[] args) {
        ThreadSample sample = new ThreadSample();
        // 스레드를 시작합니다.
        sample.start();
    }

}
```

> 스레드의 실행은 run() 호출이 아닌 start() 호출로 해야한다.
> 

***Why?***

우리는 분명 run() 메소드를 정의했는데, 실제 스레드 작업을 시키려면 start()로 작업해야 한다고 한다.

run()으로 작업 지시를 하면 스레드가 일을 안할까? 그렇지 않다. 두 메소드 모두 같은 작업을 한다. **하지만 run() 메소드를 사용한다면, 이건 스레드를 사용하는 것이 아니다.**

Java에는 콜 스택(call stack)이 있다. 이 영역이 실질적인 명령어들을 담고 있는 메모리로, 하나씩 꺼내서 실행시키는 역할을 한다.

만약 동시에 두 가지 작업을 한다면, 두 개 이상의 콜 스택이 필요하게 된다.

**스레드를 이용한다는 건, JVM이 다수의 콜 스택을 번갈아가며 일처리**를 하고 사용자는 동시에 작업하는 것처럼 보여준다.

즉, run() 메소드를 이용한다는 것은 main()의 콜 스택 하나만 이용하는 것으로 스레드 활용이 아니다. (그냥 스레드 객체의 run이라는 메소드를 호출하는 것 뿐이게 되는 것..)

start() 메소드를 호출하면, JVM은 알아서 스레드를 위한 콜 스택을 새로 만들어주고 context switching을 통해 스레드답게 동작하도록 해준다.

우리는 새로운 콜 스택을 만들어 작업을 해야 스레드 일처리가 되는 것이기 때문에 start() 메소드를 써야하는 것이다!

### 스레드 동기화 방법

- 임계 영역(critical section) : 공유 자원에 단 하나의 스레드만 접근하도록(하나의 프로세스에 속한 스레드만 가능)
- 뮤텍스(mutex) : 공유 자원에 단 하나의 스레드만 접근하도록(서로 다른 프로세스에 속한 스레드도 가능)
- 이벤트(event) : 특정한 사건 발생을 다른 스레드에게 알림
- 세마포어(semaphore) : 한정된 개수의 자원을 여러 스레드가 사용하려고 할 때 접근 제한
- 대기 가능 타이머(waitable timer) : 특정 시간이 되면 대기 중이던 스레드 깨움

### 동기화란?

- 여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외하고 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념입니다.
- 데이터의 thread-safe를 하기 위해 자바에서 Synchronized 키워드를 제공해 멀티 쓰레드 환경에서 쓰레드간 동기화를 시켜 데이터의 thread-safe를 보장합니다.
- Synchronized는 변수와 메소드에 사용해서 동기화 할 수 있으며, Synchronized 키워드를 남발하게 되면 오히려 프로그램의 성능 저하를 일으킬 수 있습니다.

**synchronized 활용**

```java
//synchronized : 스레드의 동기화. 공유 자원에 lock
public synchronized void saveMoney(int save){    // 입금
    int m = money;
    try{
        Thread.sleep(2000);    // 지연시간 2초
    } catch (Exception e){

    }
    money = m + save;
    System.out.println("입금 처리");

}

public synchronized void minusMoney(int minus){    // 출금
    int m = money;
    try{
        Thread.sleep(3000);    // 지연시간 3초
    } catch (Exception e){

    }
    money = m - minus;
    System.out.println("출금 완료");
}
```

[출처] https://adjh54.tistory.com/167
