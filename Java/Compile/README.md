## Java
**Java**: 객체지향 프로그래밍 언어

장점
- JVM(Java Virtual MAchine) 위에서 동작하기 때문에 운영체제에 독립적으로 실행가능 → 플랫폼 독립적
- GC(Garbage Collector)로 자동적인 메모리 관리 가능

단점
- JVM를 한번 더 거쳐 속도가 느림
- 인터프리터 방식으로 실행 시에 해석되어 속도가 상대적으로 느림 → 요즘은 바이트 코드를 바로 기계어로 변환해주는 JIT 컴파일러와 최적화 기술로 속도 격차가 많이 줄었다.
- 다중 상속이나 타입에 엄격하며, 제약이 많다.

<br>

## JVM
JRE에 있으며 **컴파일된 코드(바이트 코드)를 실행**시켜주는 가상의 컴퓨터.
**프로그램과 OS 사이에서 기계어로 해석해주는 번역기 역할**을 수행한다.
이로 인해 자바 프로그램이 어느 기기에서도 실행될 수 있게 만들어준다.
또한 **가비지컬렉션을 통해 자동적으로 메모리 관리**를 해준다.
HW와 OS 위에서 실행되기 때문에, JVM 자체는 플랫폼(OS)에 종속적이다. 즉, 플랫폼에 따라 호환되는 JVM을 실행시켜줘야 한다.

#### 📌 JDK, JRE, JVM 관계
![image](https://github.com/dahui0525/world_best_CS_study/assets/80496853/f6a19279-82af-4542-8889-8830701a8a2c)

    포함 관계: JDK(Compiler ~) >>> JRE(Bytecode ~) >>> JVM

    JDK(Java Development Kit)
    : JRE를 포함. 개발하기 위한 도구. JRE에는 없는 자바 컴파일러(javac, java compiler)를 포함한다.

    JRE(Java Runtime Environment)
    : 자바 클래스 라이브러리, JVM, 자바 클래스 로더를 포함. 클래스 로더와 클래스 라이브러리를 통해 작성한 자바코드를 라이브러리와 결합한 후 JVM에 넘겨 실행. JVM이 잘 동작할 수 있도록 환경을 맞춰주는 역할

### JVM의 구성요소
1. **클래스 로더(Class Loader)**
![image](https://github.com/dahui0525/world_best_CS_study/assets/80496853/b9865c91-f505-468b-88df-5b584eb697b3)
- 로드(클래스파일을 JVM 메모리에 로드) - 검증(클래스가 자바 언어 명세 및 JVM 명세대로 구성되어있는지 검사) - 준비(데이터 구조를 보고 필요로 하는 메모리 할당) - 분석(클래스의 상수 풀 내의 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경) - 초기화(클래스 변수들을 적절한 값으로 초기화)
- JVM 내부에 클래스 파일을 로드하고, 링크 및 초기화 작업을 수행한다. 클래스 로더는 필요한 클래스 파일을 찾고 동적으로 로드하여 실행 시에 클래스에를 사용할 수 있도록 한다. 로드된 클래스는 JVM의 메모리 영역에 저장된다.
2. **실행 엔진(Execution Engine)**
- JVM이 로드한 클래스 파일을 실행하는 역할. (클래스 로더를 통해 런타임 데이터 영역에 배치된) 바이트코드를 기계어로 변환하고, 이를 실행하여 프로그램을 실행한다.
- 인터프리터와 JIT(Just-In-Time) 컴파일러가 있다. 인터프리터는 바이트코드 명령어를 하나씩 해석하고 실행하는 방식으로 기본적으로 JVM은 인터프리터 방식으로 동작한다. JIT 컴파일러는 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고, 이후부터는 해당 메서드를 더이상 인터프리팅하지 않고 네이티브 코드로 직접 실행하는 방식. 전체적인 실행 속도는 인터프리터보다 빠르다. 하지만 컴파일에 시간이 오래 걸리기 때문에, 일회성 코드의 경우 인터프리터로 실행하는 것이 좀 더 빠르다.

3. **메모리 영역(Memory Areas) / 런타임 데이터 영역 (Runtime Data Areas)**
![image](https://github.com/dahui0525/world_best_CS_study/assets/80496853/eb0949d8-a978-442f-a66e-c7b2d8c9f5c3)
- JVM이 OS 위에서 실행되면서 할당받는 메모리 영역.
- 크게 5가지로 나눌 수 있다. 메서드 영역(Method Area), 힙(Heap), 스택(Stack), PC 레지스터(Program Counter Register), 네이티브 메서드 스택(Native Method Stack)이 존재한다.

> 즉, 자바 바이트코드는 클래스 로더에 의해 JVM 내로 로드되고, 실행 엔진에 의해 기계어로 해석되어, 메모리에 배치된다.

<br>

## 자바 컴파일 순서
![image](https://github.com/dahui0525/world_best_CS_study/assets/80496853/d99a74bd-e0f8-4665-9a72-7ffd71f73094)

1. 개발자가 소스코드(.java 파일) 생성
2. 자바 컴파일러가 소스코드를 컴파일
    - 이때 나오는 파일이 자바 바이트코드(.class 파일)
3. 컴파일된 바이트 코드를 JVM의 클래스로더에 전달
4. 클래스 로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스를 로딩 및 링크하여 런타임 데이터 영역(Runtime Data Area), 즉 JVM의 메모리에 올린다.
5. 실행엔진은 JVM 메모리에 올라온 바이트코드들을 명령어 단위로 하나씩 가져와서 실행
    - 이때, 실행 엔진은 인터프리터와 JIT 컴파일러 두가지 방식이 있다.

<br> 

## ❓ 면접질문
**Q. 자바의 컴파일 과정에 대해 설명해주세요.**
```
A. 개발자가 만든 소스코드인 .java 파일을 자바 컴파일러(javac)가 자바 바이트코드인 .class 파일로 컴파일합니다. 이 바이트코드는 런타임 시에 클래스 로더에 전달되어 JVM의 메모리 영역에 올라갑니다. 그 후 실행엔진이 인터프리터나 JIT 컴파일러 방식 중 하나로 해석하고 실행합니다. 
```

<br>

**Q. JVM의 동작과정에 대해 말해주세요.**
```
A. 
``` 

<br>

<br><br><br><br>


출처: [JDK, JRE, JVM 관계](https://m.blog.naver.com/goreng2/221770110714), [JVM 동작원리 및 기본개념](https://steady-snail.tistory.com/67#JAVA_%ED%83%84%EC%83%9D%EB%B0%B0%EA%B2%BD), [JVM 구조와 장점](https://wonsjung.tistory.com/574)


